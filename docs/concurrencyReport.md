# 동시성 제어 방식 분석 보고서
***
<br>


## 개요 
***

* [동시성 발생 시나리오 정리]()
* [동시성 제어 방식 종류]()
  * [DB LOCK]()
    * [낙관적 LOCK]()
    * [비관적 LOCK]()
  * [분산 LOCK]()

* [각 방식별 비교 분석]()
* [마무리]()





## 동시성 발생 시나리오 정리
***

해당 서버는 콘서트를 예약하는 시나리오를 갖고 있습니다.  
해당 서버에서 가능한 서비스는 아래와 같습니다.

* 대기열 서비스
* 콘서트
  * 콘서트 날짜 조회 서비스
  * 콘서트 좌석 조회 서비스
  * 콘서트 좌석 예약 서비스
* 결제
  * 콘서트 결제 서비스
* 포인트
  * 포인트 충전 서비스
  * 포인트 조회 서비스


이중에서 가장 동시성 문제가 많이 예상 되는 부분은 첫번째로 좌석예약 서비스 입니다.  
해당 서비스는 선착순으로 진행되어야하고 한 사람이 동일한 자원이 한 좌석이 예약을 하는 순간  
다른 예약 시도는 FAIL 이 되어야만 하기 때문입니다.

따라서 좌석 예약 시스템을 기준으로 동시성에 필요한 제어 방식을  
분석 해보겠습니다.


<br>

## 동시성 제어 방식 종류
***

자료조사 결과 동시성 제어방식은 2가지로 정리되었습니다.

`Database` 의 `Lock` 기능을 이용한 `DB Lock` 방식과 

`Redis/ Kafka` 와 같은 `ThirdParty` 의 기능을 이용한 `분산 LOCK` 입니다.

기준은 동시 요청이 들어왔을 때 데이터를 확보하는 Lock 이라는 기능을 어디서 제어할 것인가 입니다.


우선 DataBase Lock 부터 보면 크게 낙관적 Lock 과 비관적 Lock 
2가지 방법이 있습니다.

* ### 낙관적 Lock 
    > 주로 동시성이 충돌이 적은 곳에 사용하며   
    Version 이라는 Row 을 생성하여   
    Version 이 같은 Transaction 에 대해서는 전부 Rollback 을 하는 경우 사용한다  
    <br>
    즉, 선착순인 하나만 성공시키고 나머지는 모두 Rollback 처리해야하는 경우 사용한다  
    이때 Rollback 에 대한 추가 로직을 작성해야한다. ( 경쟁에서 밀릴 경우 )  
     <br>
    대신 트래픽이 많아도 다른 트랜잭션을 대기할 필요없이 전부 Rollback 이 되기 때문에   
    성능이 좋다.

* ### 비관적 Lock
    > 주로 동시성 충돌이 자주 일어나면서 트랜젹선을 모두 처리해야만할 때 사용한다.  
    해당 방식은 다른 트랜잭션이 작업이 끝날때 까지 트랜잭션들이 모두 대기를 한다.  
    때문에 트래픽이 다량으로 밀릴 경우 성능에 대한 이슈가 있으며  
    무한정 대기는 일어나선 안되므로 제한 시간을 꼭 작성해야한다.  
    또한 하나의 트랜잭션이 commit 을 한 이후 다음 Transaction 에 대한 순서가 보장되어 있지 않을 수 있다.  



<br>

다음은 ThirdParty 를 이용한 분산 Lock 의 종류입니다.

분산 Lock 의 장점으로는 
* `DataBase` 에 트래픽이 몰릴 경우 `DataBase` 부하를 줄일 수 있다
* `DataBase` 의 여러 트랜잭션이 생길 경우 발생하는 `DeadLock` 상황을 피할 수 있다.
* `DataBase` 또는 서버 가 하나가 아닌 다중 서버/ 클러스터인 경우 일정하게 보장할 수 있다.

대신 단점으로는 
* ThirdParty 에 대한 이해가 있어야 한다.
* 트랜잭션에 대한 로직을 직접 구현 해야 하므로 구현 난이도가 있다.
* ThirdParty 상태, 네트워크 상태에 따라 안정성이 결정된다.


> 구현시 고려해야할 부분!   
> DB LOCK 의 무결성을 보장해야하는 것을 무조건 고려해야 한다!  
> `락획득` -> `트랜잭션 시작` -> `로직 수행` -> `트랜잭션 종료` -> `락 해제`  
> 순서를 무조건 지켜야함



* ### Redis 이용
  > `Redis` 를 이용하여 `key` 의 생명주기를 이용하여 `Lock` 등록하고 `Lock` 을 얻습니다.  
  이때 `Lock` 을 얻는 방법을 구현하는 방법이 2가지로 나누어 지게 된다.  
  `Spin-Lock`, `Pub/Sub Lock` 이다.  
  `Spin-Lock` 은 정해진 시간 만큼 대기하는 로직으로 단순히 `Redis` 에 `Lock` 을 얻을 수 있는지
  계속해서 확인하는 방법이다.  
  콘서트 예약 애매할 때 `Polling` 방식으로 계속해서 확인하는 것과 비슷하다  
  `Pub/Sub` 방법은 무한 로딩에 빠질 수도 있는 이 방식을 구독 형식으로 구현한 것이다.  
  `Redis` 에서 `Lock` 이 해제 될때마다 구독하고 있는 `Client` 에게 알려주는 형식으로 
  불필요한 요청을 줄인 방식 이다.  

  

* ### Kafka Messing  
카프카의 순서 보장이 되는 Message Queue 를 이용하여 분산 Lock 을 구현한다 

  
<br>

## 각 방식별 비교 분석
*** 

콘서트 좌석 예약 API 에 적용하기 위한 기준을 다음과 같이 정했습니다.
* 구현이 어려운지?
* 구현에 오래 걸리는지?
* 하나만 성공해야하는가?
* DataBase 가 분산 되어있는가?
* 서버가 분산되어 있는가?
* 성능이 좋은가?



우선 구현가능성에 가장 초점을 두었으며
현재 서버 상황에 따라 구분하는게 명확할 것 같아서 
서버 상태를 추가했습니다.





<table> 
  <thead>
    <tr>
      <td></td>
      <td> 비관적 lock </td>
      <td> 낙관적 lock </td>
      <td> 분산 lock </td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>구현이 어려운가?</th>
      <td>하</td>
      <td>하</td>
      <td>상</td>
    </tr>
    <tr>
      <th>구현에 오래 걸리는지?</th>
      <td>하</td>
      <td>하</td>
      <td>상</td>
    </tr>
    <tr>
      <th>하나만 성공해야하는가?</th>
      <td>X</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <th>DataBase 가 분산 되어있는가?</th>
      <td>X</td>
      <td>X</td>
      <td>O</td>
    </tr>
    <tr>
      <th>서버가 분산되어 있는가?</th>
      <td>X</td>
      <td>X</td>
      <td>O</td>
    </tr>
    <tr>
      <th>성능이 좋은가?</th>
      <td>하</td>
      <td>중</td>
      <td>상</td>
    </tr>
  </tbody>
</table>


다음과 같은 기준에서 낙관적 Lock 을 사용하는게 

가장 빠르게 동시성을 구현할 수 있다고 결정이 됬습니다.


<br>

## 마무리
***
동시성 제어를 위해  
여러 방법들에 대해 분석하고 
적용해야할 API 특성에 대해 정리해보니  
어떤 방법이 적당한지 정합하게 찾을 수 있을 것 같습니다.

서버, 데이터 베이스가 분산되어있지 않고  
구현 난이도가 상대적으로 높지 않아  
좌석 API 낙관적 Lock 을 이용하여 구현하는게 적합합니다.

